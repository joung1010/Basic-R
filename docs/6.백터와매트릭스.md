# 벡터와 매트릭스

## 1. 벡터의 연산

### 1.1 스칼라와 벡터 연산

벡터의 모든 원소에 대해 동일한 연산이 적용됩니다.

```
a <- c(1, 2, 3)

*# 스칼라 곱셈*
2 * a         *# [1] 2 4 6# 스칼라 뺄셈*
a - 1         *# [1] 0 1 2# 복합 연산*
2 * a + 3     *# [1] 5 7 9# 다른 수학 연산들*
a^2           *# [1] 1 4 9 (제곱)*
sqrt(a)       *# [1] 1.000000 1.414214 1.732051 (제곱근)*
log(a)        *# 자연로그*
a %% 2        *# [1] 1 0 1 (나머지 연산)*
```

### 1.2 벡터 간 연산

같은 길이의 벡터끼리는 대응하는 위치의 원소들이 연산됩니다.

```
a <- c(1, 2, 3)
b <- c(5, 6, 7)  *# 원래 메모의 오타 수정# 벡터 간 덧셈*
a + b         *# [1] 6 8 10# 벡터 간 곱셈*
a * b         *# [1] 5 12 21# 결과를 새 변수에 저장*
c <- a + b    *# c: [1] 6 8 10*
```

### 1.3 벡터 재활용 (Vector Recycling)

길이가 다른 벡터 간 연산 시 짧은 벡터가 반복됩니다.

```
long_vec <- c(1, 2, 3, 4, 5, 6)
short_vec <- c(10, 20)

long_vec + short_vec  *# [1] 11 22 13 24 15 26# 설명: 10, 20이 반복되어 10, 20, 10, 20, 10, 20으로 계산됨*
```

## 2. 벡터 관련 함수들

### 2.1 통계 함수

```
numbers <- c(1, 5, 3, 9, 2, 7, 4)

*# 기본 통계값*
sum(numbers)      *# 31 (합계)*
mean(numbers)     *# 4.428571 (평균)*
median(numbers)   *# 4 (중앙값)*
max(numbers)      *# 9 (최댓값)*
min(numbers)      *# 1 (최솟값)# 분산과 표준편차*
var(numbers)      *# 8.952381 (분산)*
sd(numbers)       *# 2.992058 (표준편차)# 정렬과 범위*
sort(numbers)     *# [1] 1 2 3 4 5 7 9 (오름차순)*
sort(numbers, decreasing = TRUE)  *# [1] 9 7 5 4 3 2 1 (내림차순)*
range(numbers)    *# [1] 1 9 (최솟값, 최댓값)*
length(numbers)   *# 7 (원소의 개수)# 추가 유용한 함수들*
which.max(numbers)  *# 4 (최댓값의 위치)*
which.min(numbers)  *# 1 (최솟값의 위치)*
unique(c(1,2,2,3,3,3))  *# [1] 1 2 3 (중복 제거)*
```

### 2.2 요약 통계

```
summary(numbers)
*# Min. 1st Qu. Median  Mean 3rd Qu.  Max. #    1       2      4   4.43       7     9*
```

## 3. 논리 연산자와 조건 검색

### 3.1 논리 연산자 종류

```
연산자의미사용 예시<작다x < 5<=작거나 같다x <= 5>크다x > 5>=크거나 같다x >= 5==같다x == 5!=다르다x != 5&그리고(AND)x > 2 & x < 8``또는(OR)!아니다(NOT)!(x == 5)
```

### 3.2 논리 연산 활용 예시

```
a <- c(1, 2, 3, 4, 5, 6, 7)

*# 조건 검사 (논리 벡터 반환)*
a >= 3            *# [1] FALSE FALSE TRUE TRUE TRUE TRUE TRUE# 조건을 만족하는 값들 추출*
a[a > 3]          *# [1] 4 5 6 7# 조건을 만족하는 개수*
sum(a > 3)        *# [1] 4 (3보다 큰 값의 개수)# 조건을 만족하는 값들의 합계*
sum(a[a > 3])     *# [1] 22 (4+5+6+7)# 특정 값과 같은지 확인*
a == 3            *# [1] FALSE FALSE TRUE FALSE FALSE FALSE FALSE# 복합 조건 (3보다 크고 5보다 작은)*
cond <- a > 3 & a < 5
a[cond]           *# [1] 4# 조건 저장하여 재사용*
big_numbers <- a >= 5
a[big_numbers]    *# [1] 5 6 7# 추가 예시*
even_numbers <- a %% 2 == 0  *# 짝수 찾기*
a[even_numbers]   *# [1] 2 4 6# which() 함수로 위치 찾기*
which(a > 4)      *# [1] 5 6 7 (4보다 큰 값들의 인덱스)*
```

## 4. 리스트 (List)

### 4.1 리스트의 특징과 생성

리스트는 **서로 다른 자료형**의 값들을 저장할 수 있는 유연한 자료구조입니다.

```
*# 성적 벡터*
a <- c(80, 95, 79, 93)

*# 리스트 생성 (이름, 나이, 성적을 모두 포함)*
info <- list(name = "Teddy", age = 35, score = a)
print(info)
```

### 4.2 리스트 접근 방법

```
*# 3가지 접근 방법*
info[[1]]         *# "Teddy" (첫 번째 요소의 값)*
info$name         *# "Teddy" (이름으로 접근, 가장 일반적)*
info[["name"]]    *# "Teddy" (이름으로 접근, 동적 접근에 유용)# 성적 정보 접근*
info$score        *# [1] 80 95 79 93*
info[[2]]         *# 35 (나이)# 리스트의 구조 확인*
str(info)
names(info)       *# [1] "name" "age" "score"*
length(info)      *# 3 (리스트 요소의 개수)*
```

### 4.3 리스트 조작

```
*# 새 요소 추가*
info$grade <- "A"
info[["hobby"]] <- c("독서", "영화감상")

*# 요소 수정*
info$age <- 36

*# 중첩 리스트*
info$address <- list(city = "서울", district = "강남구")
info$address$city  *# "서울"# 리스트에서 특정 요소 제거*
info$hobby <- NULL
```

## 5. 팩터 (Factor)

### 5.1 팩터의 개념

팩터는 **범주형 데이터**(성별, 그룹 등)를 효율적으로 저장하고 처리하는 자료형입니다.

```
*# 일반 문자 벡터*
a <- c('F', 'M', 'F', 'M')
print(a)

*# 팩터로 변환*
a.new <- factor(a)
print(a)      *# [1] "F" "M" "F" "M"*
print(a.new)  *# [1] F M F M# Levels: F M*

class(a)      *# "character"*
class(a.new)  *# "factor"*
```

### 5.2 팩터의 특징

```
scores <- c(80, 95, 79, 93)
gender <- factor(c('F', 'M', 'F', 'M'))

*# 일반 벡터와 팩터의 인덱싱 비교*
scores[3]     *# 79 (숫자 그대로)*
gender[3]     *# F (팩터 레벨)# 팩터의 레벨 확인*
levels(gender)        *# [1] "F" "M"# 팩터를 정수로 변환 (내부 저장 방식)*
as.integer(gender)    *# [1] 1 2 1 2 (F=1, M=2)# 팩터를 문자로 변환*
as.character(gender)  *# [1] "F" "M" "F" "M"*
```

### 5.3 팩터 조작

```
gender <- factor(c('F', 'M', 'F', 'M'))

*# 기존 레벨 내에서 값 변경*
gender[3] <- "M"      *# 가능 (M은 기존 레벨)*
gender[4] <- "F"      *# 가능# 새로운 레벨 추가 (주의: 직접 할당 시 NA가 됨)*
gender[5] <- "F"      *# 가능 (기존 레벨)*
gender[6] <- "O"      *# 경고 발생, NA가 됨*

print(gender)         *# [1] F M M F F <NA># 올바른 새 레벨 추가 방법*
levels(gender) <- c(levels(gender), "O")  *# 레벨에 "O" 추가*
gender[6] <- "O"      *# 이제 가능# 또는 처음부터 모든 레벨 지정*
gender_new <- factor(c('F', 'M', 'F', 'M'), 
                     levels = c('F', 'M', 'O'))
```

### 5.4 팩터 활용 예시

```
*# 설문조사 데이터*
satisfaction <- factor(
  c("매우만족", "만족", "보통", "불만족", "매우만족", "만족"),
  levels = c("매우불만족", "불만족", "보통", "만족", "매우만족"),
  ordered = TRUE  *# 순서가 있는 팩터*
)

*# 팩터 요약*
table(satisfaction)     *# 빈도표*
summary(satisfaction)   *# 각 레벨별 개수# 팩터를 이용한 그룹별 분석*
scores <- c(85, 92, 78, 88, 90, 85)
groups <- factor(c("A", "B", "A", "B", "A", "B"))

tapply(scores, groups, mean)  *# 그룹별 평균# A    B # 84.33 88.33*
```

## 6. 매트릭스 (Matrix) 기초

```
*# 매트릭스 생성*
mat <- matrix(1:12, nrow = 3, ncol = 4)
print(mat)

*# 벡터와 매트릭스 연산*
mat + 10      *# 모든 원소에 10 더하기*
mat * 2       *# 모든 원소에 2 곱하기# 매트릭스 함수들*
rowSums(mat)  *# 행별 합계*
colSums(mat)  *# 열별 합계*
apply(mat, 1, mean)  *# 행별 평균*
apply(mat, 2, mean)  *# 열별 평균*
```

## 7. 정리 및 핵심 포인트

### 벡터 (Vector)

- R의 **가장 기본적인 자료구조**
- **동일한 자료형**만 저장 가능
- 인덱싱: `vector[위치]`, 조건 검색: `vector[조건]`

### 리스트 (List)

- **서로 다른 자료형** 저장 가능
- 접근 방법: `list[[인덱스]]`, `list$이름`
- 복잡한 데이터 구조를 담을 수 있음

### 팩터 (Factor)

- **범주형 데이터**를 위한 특별한 자료형
- 메모리 효율적이고 통계 분석에 유리
- 레벨(levels) 개념이 중요

# 매트릭스 (Matrix)

## 1. 매트릭스의 개념

**1.1 1차원 vs 2차원 데이터 구조**

**1차원 데이터 (벡터)**

```
*# 키 정보만 있는 1차원 데이터*
height <- c(178, 176, 180)
print(height)  *# [1] 178 176 180*
```

**2차원 데이터 (매트릭스)**

```
# 키, 몸무게, 나이가 함께 있는 2차원 데이터
# 행(row): 각 사람 (관측값)
# 열(column): 각 변수 (키, 몸무게, 나이)
```

| 키 | 몸무게 | 나이 |
| --- | --- | --- |
| 178 | 78 | 37 |
| 176 | 80 | 40 |
| 180 | 75 | 35 |

### 1.2 매트릭스의 특징

- **2차원** 형태의 데이터 구조
- **동일한 자료형**만 저장 가능 (숫자, 문자, 논리값 중 하나)
- 행(row)과 열(column)로 구성
- 통계 계산과 선형대수 연산에 효율적

## 2. 매트릭스 생성

### 2.1 matrix() 함수 사용

```
*# 기본 생성 (열 우선으로 채워짐)*
a <- matrix(1:10, nrow = 5, ncol = 2)
print(a)
*#      [,1] [,2]# [1,]    1    6# [2,]    2    7# [3,]    3    8# [4,]    4    9# [5,]    5   10# 행 우선으로 채우기 (byrow = TRUE)*
a <- matrix(1:10, nrow = 5, ncol = 2, byrow = TRUE)
print(a)
*#      [,1] [,2]# [1,]    1    2# [2,]    3    4# [3,]    5    6# [4,]    7    8# [5,]    9   10# 다른 크기로 생성*
c <- matrix(1:10, nrow = 2, ncol = 5)
print(c)
*#      [,1] [,2] [,3] [,4] [,5]# [1,]    1    3    5    7    9# [2,]    2    4    6    8   10*
```

### 2.2 벡터를 결합하여 매트릭스 생성

```
*# 벡터 준비*
a <- 1:5
b <- 6:10

*# cbind(): 열(column)로 결합*
c1 <- cbind(a, b)
print(c1)
*#      a  b# [1,] 1  6# [2,] 2  7# [3,] 3  8# [4,] 4  9# [5,] 5 10# rbind(): 행(row)으로 결합*
r1 <- rbind(a, b)
print(r1)
*#   [,1] [,2] [,3] [,4] [,5]# a    1    2    3    4    5# b    6    7    8    9   10# 기존 매트릭스에 추가*
r3 <- rbind(r1, a)  *# r1에 벡터 a를 행으로 추가*
print(r3)
*#   [,1] [,2] [,3] [,4] [,5]# a    1    2    3    4    5# b    6    7    8    9   10# a    1    2    3    4    5*
```

### 2.3 매트릭스에 벡터 추가

```
*# 기존 매트릭스*
c <- matrix(1:10, nrow = 2, ncol = 5)
print(c)

*# 새 열 추가*
x <- c(3, 5)
c2 <- cbind(c, x)
print(c2)
*#      [,1] [,2] [,3] [,4] [,5] x# [1,]    1    3    5    7    9 3# [2,]    2    4    6    8   10 5# 새 행 추가*
y <- c(11, 12, 13, 14, 15)
c3 <- rbind(c, y)
print(c3)
*#   [,1] [,2] [,3] [,4] [,5]#      1    3    5    7    9#      2    4    6    8   10# y   11   12   13   14   15*
```

## 3. 매트릭스 인덱싱

### 3.1 기본 인덱싱

```
*# 매트릭스 생성*
a <- matrix(1:21, nrow = 3, ncol = 7)
print(a)
*#      [,1] [,2] [,3] [,4] [,5] [,6] [,7]# [1,]    1    4    7   10   13   16   19# [2,]    2    5    8   11   14   17   20# [3,]    3    6    9   12   15   18   21# 특정 원소 접근 [행, 열]*
a[2, 3]         *# 2행 3열: 8*
a[1, 6]         *# 1행 6열: 16# 전체 행 또는 열*
a[2, ]          *# 2행 전체: 2  5  8 11 14 17 20*
a[, 3]          *# 3열 전체: 7 8 9# 부분 행렬*
a[2, 1:3]       *# 2행의 1~3열: 2 5 8*
a[1:2, 2:4]     *# 1~2행의 2~4열*
```

### 3.2 고급 인덱싱

```
*# 특정 행들과 열들 선택*
a[c(1, 3), c(2, 4, 6)]  *# 1,3행과 2,4,6열의 교집합# 조건부 인덱싱*
a[a > 10]       *# 10보다 큰 모든 원소들을 벡터로 반환# 음수 인덱싱 (제외)*
a[-1, ]         *# 첫 번째 행 제외*
a[, -c(1, 3)]   *# 1,3번째 열 제외# 논리 인덱싱*
mask <- a > 15
a[mask]         *# 15보다 큰 원소들*
```

## 4. 매트릭스에 이름 부여

```
*# 매트릭스 생성*
people_data <- matrix(c(178, 176, 180, 78, 80, 75, 37, 40, 35), 
                      nrow = 3, ncol = 3)

*# 행과 열에 이름 부여*
rownames(people_data) <- c("김철수", "이영희", "박민수")
colnames(people_data) <- c("키", "몸무게", "나이")

print(people_data)
*#        키 몸무게 나이# 김철수 178     78   37# 이영희 176     80   40# 박민수 180     75   35# 이름으로 접근*
people_data["김철수", "키"]          *# 178*
people_data[c("김철수", "박민수"), "몸무게"]  *# 78 75*
people_data["이영희", ]               *# 이영희의 모든 정보*
```

## 5. 매트릭스 연산

### 5.1 기본 연산

```
mat1 <- matrix(1:6, nrow = 2, ncol = 3)
mat2 <- matrix(7:12, nrow = 2, ncol = 3)

print(mat1)
print(mat2)

*# 요소별 연산*
mat1 + mat2     *# 요소별 덧셈*
mat1 - mat2     *# 요소별 뺄셈*
mat1 * mat2     *# 요소별 곱셈*
mat1 / mat2     *# 요소별 나눗셈# 스칼라와의 연산*
mat1 + 10       *# 모든 원소에 10 더하기*
mat1 * 2        *# 모든 원소에 2 곱하기*
```

### 5.2 선형대수 연산

```
*# 정방행렬 생성*
A <- matrix(c(1, 2, 3, 4), nrow = 2)
B <- matrix(c(5, 6, 7, 8), nrow = 2)

*# 행렬 곱셈*
A %*% B         *# 행렬 곱셈 (선형대수)# 전치행렬*
t(A)            *# A의 전치행렬# 역행렬 (정방행렬이고 역행렬이 존재할 때)*
solve(A)        *# A의 역행렬# 대각합 (trace)*
sum(diag(A))    *# 대각선 원소들의 합*
```

## 6. 매트릭스 관련 함수들

```
mat <- matrix(1:12, nrow = 3, ncol = 4)

*# 차원 정보*
dim(mat)        *# [1] 3 4 (행, 열 개수)*
nrow(mat)       *# 3 (행 개수)*
ncol(mat)       *# 4 (열 개수)*
length(mat)     *# 12 (전체 원소 개수)# 통계 함수*
sum(mat)        *# 모든 원소의 합*
mean(mat)       *# 모든 원소의 평균*
max(mat)        *# 최댓값*
min(mat)        *# 최솟값# 행/열별 통계*
rowSums(mat)    *# 각 행의 합*
colSums(mat)    *# 각 열의 합*
rowMeans(mat)   *# 각 행의 평균*
colMeans(mat)   *# 각 열의 평균# apply 함수 사용*
apply(mat, 1, sum)    *# 행별 합계 (margin = 1)*
apply(mat, 2, mean)   *# 열별 평균 (margin = 2)*
apply(mat, 1, max)    *# 행별 최댓값*
```

## 7. 실전 예제

### 예제 1: 학생 성적 매트릭스

```
*# 학생별 과목 점수 데이터*
scores <- matrix(c(85, 92, 78, 88,    *# 수학*
                   78, 85, 82, 91,    *# 영어*  
                   92, 88, 85, 87),   *# 과학*
                 nrow = 4, ncol = 3, byrow = FALSE)

*# 행과 열에 이름 부여*
rownames(scores) <- c("김철수", "이영희", "박민수", "최지영")
colnames(scores) <- c("수학", "영어", "과학")

print(scores)

*# 분석*
cat("학생별 총점:\n")
print(rowSums(scores))

cat("\n학생별 평균:\n")
print(round(rowMeans(scores), 1))

cat("\n과목별 평균:\n")
print(round(colMeans(scores), 1))

*# 최고점 학생과 과목 찾기*
max_pos <- which(scores == max(scores), arr.ind = TRUE)
cat("\n최고점:", max(scores), "점\n")
cat("학생:", rownames(scores)[max_pos[1]], "\n")
cat("과목:", colnames(scores)[max_pos[2]], "\n")
```

### 예제 2: 매트릭스 확장

```
*# 기존 성적 매트릭스에 새 학생과 새 과목 추가*
new_student <- c(90, 95, 89)  *# 정다은의 성적*
expanded_scores <- rbind(scores, 정다은 = new_student)

*# 체육 점수 추가*
pe_scores <- c(88, 91, 85, 92, 87)
final_scores <- cbind(expanded_scores, 체육 = pe_scores)

print(final_scores)

*# 새로운 분석*
print("확장된 데이터의 학생별 평균:")
print(round(rowMeans(final_scores), 1))
```

### 예제 3: 매트릭스 조건 검색

```
*# 80점 이상인 점수들 찾기*
high_scores <- scores >= 80
print("80점 이상 과목 (TRUE/FALSE):")
print(high_scores)

*# 각 학생의 80점 이상 과목 수*
print("학생별 80점 이상 과목 수:")
print(rowSums(high_scores))

*# 90점 이상인 모든 점수*
excellent_scores <- scores[scores >= 90]
print("90점 이상인 모든 점수:")
print(excellent_scores)
```

## 8. 매트릭스 vs 데이터프레임

| 특성 | 매트릭스 | 데이터프레임 |
| --- | --- | --- |
| 자료형 | 동일한 자료형만 | 서로 다른 자료형 가능 |
| 차원 | 2차원 | 2차원 |
| 용도 | 수치 계산, 선형대수 | 실제 데이터 분석 |
| 인덱싱 | `[행, 열]` | `[행, 열]`, `$열이름` |

```
*# 매트릭스 → 데이터프레임 변환*
df_scores <- as.data.frame(scores)
class(df_scores)  *# "data.frame"# 데이터프레임 → 매트릭스 변환 (모든 열이 같은 타입이어야 함)*
mat_scores <- as.matrix(df_scores)
class(mat_scores)  *# "matrix"*
```

---

**매트릭스 핵심 포인트:**

- **2차원 동질적** 자료구조
- **수치 계산**에 최적화
- **선형대수 연산** 지원
- 인덱싱: `[행, 열]` 형식 사용
- **실제 데이터 분석**에서는 데이터프레임을 더 많이 사용